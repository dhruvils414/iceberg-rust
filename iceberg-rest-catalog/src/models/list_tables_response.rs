/*
 * Apache Iceberg REST Catalog API
 *
 * Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use iceberg_rust::catalog::identifier::Identifier;

use crate::models;

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListTablesResponse {
    /// An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server. Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response. Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request. Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response. Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
    #[serde(
        rename = "next-page-token",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub next_page_token: Option<Option<String>>,
    #[serde(rename = "identifiers", skip_serializing_if = "Option::is_none")]
    pub identifiers: Option<Vec<Identifier>>,
}

impl ListTablesResponse {
    pub fn new() -> ListTablesResponse {
        ListTablesResponse {
            next_page_token: None,
            identifiers: None,
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use iceberg_rust::catalog::identifier::Identifier;
    use serde_json::{json, Value};

    #[test]
    fn test_list_tables_response_serialization() {
        let identifiers = vec![
            Identifier::parse("db.table1", None).unwrap(),
            Identifier::parse("db.table2", None).unwrap(),
        ];

        let response = ListTablesResponse {
            next_page_token: None,
            identifiers: Some(identifiers),
        };

        let expected_json = json!({
            "identifiers": [
                {
                    "namespace": ["db"],
                    "name": "table1"
                },
                {
                    "namespace": ["db"],
                    "name": "table2"
                }
            ]
        });

        let serialized = serde_json::to_value(&response).unwrap();
        assert_eq!(serialized, expected_json);
    }

    #[test]
    fn test_list_tables_response_deserialization() {
        let json_value = json!({
            "identifiers": [
                {
                    "namespace": ["db"],
                    "name": "table1"
                },
                {
                    "namespace": ["db"],
                    "name": "table2"
                }
            ]
        });

        let expected_response = ListTablesResponse {
            next_page_token: None,
            identifiers: Some(vec![
                Identifier::parse("db.table1", None).unwrap(),
                Identifier::parse("db.table2", None).unwrap(),
            ]),
        };

        let deserialized: ListTablesResponse = serde_json::from_value(json_value).unwrap();
        assert_eq!(deserialized, expected_response);
    }
}
